#pragma once
#include "DS_singly_linked_list.h"

// Глава 3 Связные списки
namespace std_3
{
    // 3.1 Основные положения
    namespace std_3_1
    {
        /*
            Связный список построен из объектов, обычно называемых ячейками. Этот класс содержит все данные, которые должны храниться в списке, и ссылку на другую ячейку.
                Ссылка представляет собой справку или указатель на объект такого же класса. Поле типа «указатель» в ячейке часто называется Next.
                Переменная top — это указатель на первую ячейку списка
            Связные списки — хороший способ хранить элементы, количество которых может со временем увеличиваться или уменьшаться. Чтобы присовокупить новую ячейку,
                нужно всего лишь добавить ее в начало или в конец связного списка. Массив располагает фиксированным размером, поэтому его сложно увеличить, если
                требуется включить новые элементы.
        */
    }
    // 3.2 Однонаправленные связные списки
    namespace std_3_2
    {
        /*
            В однонаправленном связном списке каждая ячейка связана со следующей с помощью одинарной ссылки. Чтобы использовать такой список, вам понадобятся алгоритмы
                для передвижения по списку, поиска, добавления и удаления элементов. Рассмотрим некоторые из них.
        */
        // 3.2.1 Передвижение по спискам
        namespace std_3_2_1
        {
            /*
                Данный алгоритм начинается с цикла While, который работает до тех пор, пока верхний указатель ячейки не станет null. Внутри цикла алгоритм сперва вызывает
                    метод Print, чтобы показать значение ячейки top, а затем с ее помощью указывает на следующую ячейку связного списка. Процесс продолжается до тех пор,
                    пока top не станет указывать на null в конце списка и цикл While не остановится.
                Приведенный алгоритм изучает каждую ячейку в связном списке, поэтому если их количество равно N, то время работы составит O(N).
            */
            void Iterate();
        }
        // 3.2.2 Нахождение ячеек
        namespace std_3_2_2
        {
            /*
                Алгоритм вводит цикл While, который работает, пока top не станет равным null. Внутри этого цикла сравнивается значение ячейки top с искомым значением.
                    Если они совпадают, алгоритм возвращает top; если нет, top превращается в указатель на следующую ячейку в списке.
                Если top становится равным null после того, как будет пересмотрен весь список, — искомого значения нет. Возможно также, что в алгоритме вызвано исключение
                    или возникла какая-то ошибка (зависит от используемого языка программирования).
            */
            template <typename T>
            T &List<T>::findcell(T data);
            /*
                В следующих разделах вы увидите, что легче всего работать с ячейкой в связном списке, если есть указатель на ту, что стоит перед ней. Приведенный ниже
                    алгоритм находит ячейку, предшествующую целевой.
                Код подобен предыдущему, но в нем есть два отличия. Первое заключается в том, что перед началом работы проверяется, принимает ли top значение null. Это
                    помогает понять, можно ли рассматривать top.Next без риска. Ведь если top.Next окажется неопределенным, программа, использующая такой алгоритм, зависнет.
                    В случае когда top не является null, алгоритм вводит цикл While, однако на этот раз вместо top.Value рассматривается top.Next.Value. Если удается отыскать
                    искомое значение, top указывает на ячейку перед той, которая его содержит, и алгоритм возвращает top.
            */
            template <typename T>
            T &List<T>::findcellbefore(T data);
        }
        // 3.2.3 Использование ограничителей
        namespace std_3_2_3
        {
            /*
                Если внимательно изучить приведенный выше алгоритм, легко представить случай, при котором он даст сбой. Например, когда искомое значение содержится в первой
                    ячейке связного списка, то перед ней не окажется ячейки и алгоритм не сможет ничего вернуть. Первое значение, которое он станет рассматривать, будет
                    находиться во второй ячейке списка, а алгоритм никогда не возвращается назад.
                Один из способов справиться с описанной проблемой — добавить специальный код, который отыщет искомое значение непосредственно в первой ячейке. Но если
                    программе придется рассматривать эту ситуацию в качестве особого случая, она может запутаться.
                Другой подход — создать ограничитель в начале списка. Он представляет собой ячейку, которая является частью связного списка, но не содержит какие-либо
                    значимые данные. Ограничитель используется только в качестве метки-заполнителя, поэтому алгоритмы могут свободно обращаться к нему.
                Если искомого значения не окажется, в поле зрения попадет каждая ячейка. То есть если список содержит N ячеек, время работы алгоритма будет определяться как
                    O(N). На первый взгляд, может показаться, что ограничитель только занимает место. На самом деле он отменяет необходимость использовать специальный код и
                    упрощает алгоритм, а также делает его более изящным.
            */
            template <typename T>
            T &List<T>::findcellbeforelimiter(T data);
        }
        // 3.2.4 Добавление ячеек в начало списка
        namespace std_3_2_4
        {
            /*
                Алгоритм устанавливает новый указатель ячейки Next таким образом, чтобы он указывал вначале на ту ячейку, которая идет первой после ограничителя в списке, а
                    затем на новую. Получается, что новая ячейка размещается после ограничителя и становится первой в связном списке.
                    Указанный алгоритм состоит всего из двух шагов, поэтому время его работы равно O(1), независимо от количества ячеек в списке.
            */
            template <typename T>
            void List<T>::push_front(T data);
        }
        // 3.2.5 Добавление ячеек в конец списка
        namespace std_3_2_5
        {
            /*
                Код проходит по связному списку вплоть до последней ячейки и делает так, чтобы ее ссылка указывала сначала на новую ячейку, а та в свою очередь на null.
                    Алгоритм выглядел бы более беспорядочным, если бы в списке отсутствовал ограничитель. Вы можете использовать специальный код в том случае, если список
                    пуст, а top указывает на null.
                Алгоритм должен пройти через весь список, поэтому, если в списке содержится N ячеек, время его работы составит O(N).
            */
            template <typename T>
            void List<T>::push_back(T data);
        }
        // 3.2.6 Вставка ячеек
        namespace std_3_2_6
        {
            /*
                Поскольку алгоритм проходит всего два шага, он работает в течение O(1) времени, хотя может понадобиться и O(N) времени, чтобы найти ячейку after_me.
                    Например, если вы хотите вставить ячейку после ячейки, содержащей искомое значение, для начала придется ее отыскать.
            */
            template <typename T>
            void List<T>::insert(T data, int index);
        }
        // 3.2.7 Удаление ячеек
        namespace std_3_9
        {
            /*
                В C# и Visual Basic для управления памятью используется метод «сборки мусора», который автоматически утилизирует удаленные ячейки, если программе требуется
                    больше памяти. Однако в некоторых языках программирования могут понадобиться дополнительные действия. Следующая версия алгоритма демонстрирует
                    освобождение целевой ячейки в C++.
            */
            template <typename T>
            void List<T>::removeAt(int index);
            /*
                От языка программирования зависит и то, как вы будете удалять связный список. В C# и Visual Basic достаточно приравнять все ссылки на список к значению null,
                    и «сборка мусора» его утилизирует. А в C++, например, нужно пройти по cписку и освободить каждую ячейку непосредственно, как показано в следующем псевдокоде.
            */
            template <typename T>
            void List<T>::clear();
        }
    }
    // 3.3 Двунаправленные связные списки
    namespace std_3_3
    {
        /*
            В двунаправленных списках ссылки ячеек указывают на следующие и предыдущие ячейки. Вторые часто называют Prev, или Previous.
            В подобных структурах данных удобно иметь верхний и нижний ограничители, чтобы программа легко управляла списком с обоих концов, например добавляла
                и удаляла элементы. Такой подход позволяет это сделать за время, равное O(1).
            Вот как выглядит псевдокод, добавляющий ячейку после выбранной.
        */
        template <typename T>
        void ListTest<T>::insert(T data, int index);
    }
    // 3.4 Сортированные списки
    namespace std_3_4
    {
        /*
            Иногда элементы связного списка удобно хранить в отсортированном виде. В этом случае чтобы добавить элемент, нужно найти позицию, к которой он принадлежит, 
                и обновить соответствующие ссылки. Рассмотрим, как выполняется подобное действие для сортированного однонаправленного списка.
            
        */
        template <typename T>
        void insertCell(T data);
        /*
            В худшем случае алгоритму понадобится пересмотреть весь список, чтобы найти верное местонахождение нового элемента. Таким образом, если ячеек N, 
                время работы составит O(N), и, хотя теоретически его улучшить невозможно, на практике алгоритм получится ускорить, добавив нижний ограничитель. 
                Когда значение Value нижнего ограничителя будет превышать любое аналогичное значение из ячеек, тест top.Next != null можно удалить. Такое допустимо,
                поскольку код все равно отыщет местоположение для новой ячейки, даже если оно будет находиться прямо перед нижним ограничителем.
        */
        template <typename T>
        void insertCelllimiter(T data);
    }
    // 3.5 Алгоритмы для работы со связными списками
    namespace std_3_5
    {
        // 3.5.1 Копирование
        namespace std_3_5_1
        {
            
        }
        // 3.5.2 Сортировка вставкой
        namespace std_3_5_2
        {
         
           
        }
        // 3.5.3 Сортировка методом выбора
        namespace std_3_5_3
        {
            
        }
    }
    // 3.6 Многопотоковые связные списки
    namespace std_3_6
    {
        /*
            В однонаправленном связном списке каждая ячейка содержит ссылку на следующую ячейку, в двунаправленном — на следующую и предыдущую. Это необходимо
                для того, чтобы обеспечить два способа перемещения — прямой и обратный. Однако к ячейкам списка можно добавлять и другие ссылки, чтобы
                предусмотреть иные способы перемещения.
            Предположим, вы построили класс Planet для хранения информации о планетах Солнечной системы и назначили ему поле с именем NextDistance, в котором
                находятся сведения о расстояние до Солнца. С учетом этого список будет организован в следующем порядке: Меркурий, Венера, Земля, Марс, Юпитер,
                Сатурн, Уран, Нептун (и Плутон, если захотите включить и его). Аналогичным образом можно добавить и другие поля, чтобы отсортировать планеты по
                их массе, диаметру и т. д. Каждое такое прохождение через ячейки, определенные набором ссылок, называется потоком.
            Потоки могут иметь и другие структуры данных, например дерево. В этом случае оно позволяет программе посетить все его вершины в нетипичном порядке.
        */
    }
    // 3.7 Связные списки с циклами
    namespace std_3_7
    {
        /*
            Кольцевой связный список — это связный список, в котором последняя ссылка указывает на первый элемент списка (рис. 3.9). Он может быть полезен в том
                случае, когда в рамках цикла нужно бесконечно проходить через последовательность элементов. Так, операционная система способна повторять цикл
                процессов, чтобы запустить каждый из них. Если начался новый процесс, он может быть добавлен в любое место списка, например за ограничителем,
                что позволит ему сразу запуститься.
            Еще одним примером служит игра, которая бесконечно циклически проходит по списку объектов, позволяя каждому из них передвигаться по экрану. И снова
                новые объекты можно добавлять в список куда угодно. На рисунке 3.10 показан кольцевой связный список, в который включены не все ячейки. В этом
                случае возникают два интересных вопроса. Во-первых, как определить, содержит ли связный список такой цикл? Во-вторых, если связный список содержит
                подобный цикл, как узнать, где он начинается и как его прервать? Последний вопрос, по сути, связан с определением конца списка.
            Взглянув еще раз на рисунок 3.10, вы можете определить, что конец списка — это ячейка I, поскольку ее посещают последней перед тем, как начнется 
                очередной повтор действий. В следующих разделах описаны некоторые из наиболее интересных алгоритмов, помогающие ответить на поставленные вопросы.
        */
        // 3.7.1 Маркировка ячеек
        namespace std_3_7_1
        {
            /*
                Возможно, самый легкий способ определить, имеет ли связный список цикл, — пройти через его ячейки и пометить каждую. Если очередная 
                    рассматриваемая ячейка окажется помеченной, значит, в списке есть цикл и он начинается в этом месте.
            */
            bool CycleON(int index);
            bool Has_loopMarking();
            /*
                Алгоритм проходит через цикл дважды: вначале, чтобы присвоить флажку Visited в каждой ячейке значение true, а затем, чтобы поменять его на false.
                    Если в списке N ячеек, то алгоритм совершает 2N шагов и работает в течение времени O(N).
                Кроме того, алгоритм требует, чтобы для каждой ячейки было добавлено поле Visited, поэтому ему понадобится O(N) времени. Поскольку список уже
                    занимает O(N) места для хранения ячеек и их ссылок, это не должно стать проблемой. Однако следует помнить, что алгоритм все же требователен
                    к памяти.
                Нередко в подобных задачах есть дополнительное условие, запрещающее добавлять поле Visited. Этому ограничению соответствуют рассмотренные ниже 
                    алгоритмы.
            */
        }
        // 3.7.2 Использование хеш - таблиц
        namespace std_3_7_2
        {
            /*
                Все, что вам необходимо знать о них сейчас, — такие таблицы помогают очень быстро сохранять и находить элементы, а также выявлять их наличие в
                    принципе.
                Представленный ниже алгоритм перемещается по списку и добавляет каждую ячейку в хеш-таблицу, предварительно проверяя, нет ли ее уже там. Если он
                    доходит до ячейки, которая присутствует в хеш-таблице, значит, с нее в списке начинается цикл.
                Работу приведенного кода демонстрирует программа BreakLoopHashtable, которую вы можете загрузить на сайте с материалами книги. Алгоритм проходит
                    через ячейки списка один раз, поэтому если в списке содержится N ячеек, то выполняется N шагов, а время работы составляет O(N).
                Для этого алгоритма также нужна хеш-таблица. Лучше всего, если ее размер будет превышать количество действительных значений. В таком случае
                    хеш-таблица должна располагать пространством для более чем N записей, например 1,5N. Это повысит производительность и займет O(N) места.
                Рассмотренный код придерживается ограничения (нельзя изменять класс ячейки), но использует дополнительную память. В следующих разделах описаны 
                    алгоритмы, которые определяют циклы, обходясь без нее.
            */
        }
        // 3.7.3 Повторная трассировка списка
        namespace std_3_7_3 
        {
            /*
                Алгоритм проводит по списку один объект, а затем в его поисках через каждую посещенную ячейку проходит второй объект. Это слегка запутанное 
                    объяснение легче понять, если взглянуть на следующий псевдокод.
            */
            bool Has_LoopRetracing();
            /*
                Работу этого алгоритма демонстрирует программа BreakLoopHashtable, которую можно скачать на сайте с материалами книги.
                Предположим, что в списке N ячеек. Когда объект алгоритма cell проверяет K-ю ячейку, объект tracer должен пройти вверх по списку до этой точки. 
                    Таким образом, он выполнит K шагов. Это значит, что общее время работы алгоритма составит 1 + 2 + 3 + ... + N = N u (N – 1)/2 = O(N2). 
                    Оно меньше, чем у предыдущих алгоритмов, но зато не требуется дополнительной памяти.
            */
        }
        // 3.7.4 Реверсирование списка
        namespace std_3_7_4
        {
            /*
                Алгоритм проходит по ячейкам списка, меняя каждую ссылку таким образом, чтобы она указывала на предыдущую ячейку, а не на последующую. Если
                    алгоритм обнаруживает значение null до ограничителя, цикла в списке нет. Конечно, описанное действие преобразует ссылки, поэтому алгоритм
                    опять проходит по списку и восстанавливает их, чтобы они снова указывали на изначальные ячейки.
                Прояснит подобный принцип рисунок 3.11. Верхний фрагмент — это оригинальный список, а закрашенная ячейка — та, через которую проходит алгоритм в
                    настоящее время, реверсируя ссылки. На среднем фрагменте видно, что алгоритм достиг ячейки I (измененные ссылки показаны толстыми стрелками)
                    и должен проследовать в ячейку D, а из нее по реверсированным ссылкам в ячейки C, B и A. В результате совершенных действий ссылки изменятся
                    снова, что отражено на нижнем фрагменте пунктиром. В этом месте алгоритм возвращается к первой ячейке и определяет, что список содержит цикл.
                    Обратите внимание: новый список выглядит так же, как и старый, только ссылки в цикле имеют обратное направление.
                Поскольку такой алгоритм должен реверсировать список дважды, он начинается со следующего метода.
            */
            Node<T> *ReverseList(Node<T> *sentinel);
            /*
                Приведенный псевдокод перемещается по списку, меняет ссылки и возвращает последний посещенный им элемент, который теперь становится первым. 
                Следующий алгоритм использует предыдущий псевдокод, чтобы определить наличие цикла.
            */
            bool Has_LoopReversing();
            /*
                Указанный алгоритм вызывает реверсирующий метод ReverseList дважды: сперва, чтобы получить первую ячейку измененного списка, а затем, чтобы
                    восстановить начальные значения ссылок. Если при этом ограничитель окажется таким же, как и в первой ячейке нового списка, алгоритм вернет
                    значение true; если нет — false. В целом же выполняется 2N = O(N) шагов.
                Алгоритм работает за время O(N) и не требует дополнительных ресурсов. Но у него есть и недостаток, который заключается в том, что он способен лишь 
                    обнаружить цикл, но не остановить его. Следующий алгоритм решает и эту задачу, зато является, возможно, наиболее сложным из всех описанных в 
                    текущем разделе.
            */
        }
        // 3.7.5 Черепаха и кролик
        namespace std_3_7_5
        {
            /*
                Алгоритм кролика и черепахи, который также называется алгоритмом нахождения циклов Флойда, придуман Робертом Флойдом в 1960-х гг.
                Алгоритм запускает два объекта: «черепаху» и «кролика». Они двигаются из начала списка, но с разными скоростями: «черепаха» преодолевает за один
                    шаг одну ячейку, а «кролик» — две. Когда последний достигает ссылки со значением null — список окончен и цикла в нем нет. Если же цикл есть,
                    «кролик» входит в него и начинает бегать по кругу. Тем временем «черепаха» ползет, пока не дойдет до цикла и в какой-то момент не окажется в
                    нем вместе с «кроликом».
                Пусть L — количество ячеек внутри цикла, T — количество шагов, пройденных «черепахой», чтобы попасть в цикл, а H — расстояние от начала цикла до
                    того положения, в котором за это же количество шагов оказался «кролик». Тогда, согласно рисунку 3.12, L = 5, T = 4, H = 4.
                Поскольку «кролик» перемещается в два раза быстрее «черепахи», он доходит до цикла через T ячеек и преодолевает еще T ячеек внутри цикла, чтобы
                    оказаться в позиции, как на рисунке 3.12. Это приводит к факту № 1.(Если вы перемещаетесь через T ячеек внутри цикла, то заканчиваете свой путь за H ячеек от того места, где его начали.)
                Обратите внимание, что «кролик» мог пробежать несколько кругов по циклу, если L намного меньше T. Например, если L = 5, а T = 102, черепаха дойдет
                    до цикла за 102 шага. «Кролик» же добирается до цикла за 51 шаг, совершает 50 шагов (преодолевает 100 ячеек), пробегая 20 кругов по циклу,
                    а затем перемещается еще на один шаг (2 ячейки) внутри цикла. В таком случае H = 2.
                Возникает вопрос: когда же «кролик» догонит «черепаху»? Как только «черепаха» попадет в цикл, «кролик» окажется на H шагов впереди нее
                    (см. рис. 3.12). Однако поскольку «черепаха» и «кролик» пребывают в цикле, вы можете рассматривать последнего как отстающего на L – H ячеек.
                    Из-за того, что «кролик» перемещается на две ячейки, а «черепаха» на одну, он нагоняет по одной ячейке за шаг. Это означает, что «кролик»
                    доберется до «черепахи» за L – H шагов.
                На рисунке 3.12, где H = 4, а L = 5, «кролик» догонит «черепаху» за 5 – 4 = 1 шаг. Они встретятся в ячейке E. В этот момент «черепаха»
                    передвинется в цикле на L – H ячеек, и оба объекта будут на L – (L – H) = H ячеек ближе к началу цикла.
                    Отсюда факт № 2. (Когда «кролик» догонит «черепаху», они будут находиться за H ячеек от начала цикла.)
                Если бы вы могли переместить объект «черепаха» на H ячеек от точки встречи, он оказался бы как раз в начале цикла. К сожалению, это значение вам
                    неизвестно. Тем не менее из факта № 1 вы знаете, что если черепаха проходит через T ячеек по циклу, она закончит свой путь на расстоянии H
                    ячеек до того места, откуда стартовала, то есть остановится в начале цикла!
                Значение T тоже для вас тайна, поэтому переместить «черепаху» на указанное расстояние вы опять не можете. Однако если запустить «кролика» от 
                    начала связного списка и позволить ему проходить за раз только одну ячейку вместо двух (возможно, он устал, бегая по циклу), он также окажется
                    в начале цикла после того, как пересечет T ячеек, то есть оба объекта встретятся снова.
            */
            bool hasCycle();
        }
        // 3.7.6 Циклы в двунаправленных связных списках
        namespace std_3_7_6
        {
            /*
                Обнаружить циклы в двунаправленных списках очень просто: если они есть, указатель Next возвращается к ранней части списка. При этом Prev будет
                    указывать на уже существующую ячейку, а не на ту, которую создал цикл. Таким образом, чтобы выявить цикл, просто пройдите через список и
                    проверьте cell для каждой ячейки: Next.Prev == cell.
                Все это предполагает, что ячейки образуют двунаправленный связный список и цикл, если он существует, является обычным. Если списки Next и Prev 
                    полностью несогласованы, метод позволяет обнаружить путаницу, но не помогает исправить ее. Это больше похоже на случай с двумя потоками через 
                    одни и те же ячейки, чем на двунаправленный список с циклом.
            */
        } 
        
    }
    // 3.8 Резюме
    namespace std_3_8
    {
        /*
            В этой главе мы рассмотрели связные списки и некоторые операции, которые можно с ними совершать. Вы узнали, что такое однонаправленные,
                двунаправленные и многопотоковые списки, а также познакомились с основными алгоритмами, позволяющими находить, добавлять и удалять элементы,
                обнаруживать циклы и избавляться от них.
            Работа с указателями — это своего рода подспорье для понимания последующих глав, где рассматриваются деревья (в том числе сбалансированные), сети и 
                другие связные структуры данных. Очередная глава посвящена использованию связных структур данных для работы с разреженными массивами.
        */
    }
    // 3.9 Упражнения
    namespace std_3_9
    {
        namespace std_3_9_1
        {
            /*
                В подразделе «Добавление ячеек в конец списка» раздела «Однонаправленные связные списки» текущей главы приводится алгоритм O(N). Если вы 
                    сохраните другую переменную — bottom, — указывающую на последнюю ячейку в списке, то сможете добавлять элементы к концу списка за время O(1). 
                    Напишите код. Каким образом он усложняет другие алгоритмы, которые находят, удаляют или добавляют элемент в начало (конец) списка? 
                    Реализуйте алгоритм для удаления элемента из такого списка.
            */
        }
        namespace std_3_9_2
        {
            /*
                Разработайте алгоритм для нахождения наибольшего элемента в несортированном однонаправленном списке с ячейками, содержащими целые числа.
            */
        }
        namespace std_3_9_3
        {
            /*
                Напишите алгоритм для добавления элемента в начало двунаправленного списка.
            */
        }
        namespace std_3_9_4
        {
            /*
                Создайте алгоритм для добавления элемента в конец двунаправленного списка.
            */
        }
        namespace std_3_9_5
        {
            /*
                Если вы сравните алгоритмы из упражнений 3 и 4 с алгоритмом InsertCell из раздела «Двунаправленные связные списки» текущей главы, то заметите, 
                    что они очень похожи. Перепишите алгоритмы для упражнений 3 и 4 так, чтобы они вызывали алгоритм InsertCell, вместо того чтобы обновлять ссылки 
                    списка напрямую.
            */
        }
        namespace std_3_9_6
        {
            /*
                Напишите алгоритм, удаляющий определенную ячейку из двунаправленного списка. Представьте данный процесс в виде рисунка.
            */
        }
        namespace std_3_9_7
        {
            /*
                Предположим, у вас есть сортированный двунаправленный список с именами. Можно ли улучшить алгоритм, начав поиск не с верхнего, а с нижнего ограничителя? 
                Изменит ли это время его работы?
            */
        }
        namespace std_3_9_8
        {
            /*
                Напишите алгоритм вставки элемента в сортированный двунаправленный список, где верхний и нижний ограничители содержат минимально и максимально возможные значения.
            */
        }
        namespace std_3_9_9
        {
            /*
                Реализуйте алгоритм, который определяет, отсортирован ли связный список.
            */
        }
        namespace std_3_9_10
        {
            /*
                У алгоритмов сортировки вставкой и методом выбора теоретическое время работы одинаково — O(N2). Объясните, почему на практике второй алгоритм работает дольше.
            */
        }
        namespace std_3_9_11
        {
            /*
                Напишите программу, создающую многопотоковый список планет (см. раздел «Многопотоковые связные списки» текущей главы). Разрешите пользователю выбрать нужный переключатель 
                    или пункт выпадающего списка, чтобы отсортировать планеты по разным потокам. (Подсказка: создайте класс Planet c полями Name, DistanceToSun, Mass, Diameter, 
                    NextDistance, NextMass и NextDiameter. Затем используйте метод AddPlanetToList, чтобы добавить планету к потокам в отсортированном порядке.)
            */
        }
        namespace std_3_9_12
        {
            /*
                Создайте программу, реализующую алгоритм черепахи и кролика.
            */
        }
    }
}
// Глава 4 Массивы
namespace std_4
{
    // 4.1 Основные положения
    namespace std_4_1
    {
        /*
            Массив — это большое количество непрерывной памяти, доступ к которой осуществляется с помощью индексов (их количество указывает на размерность массива).
                Его легко представить в виде совокупности ящиков, в которых программа хранит значения
            При создании массива программа, как правило, задает его размерность и границы этой размерности.
            Кроме всего прочего, программа негласно назначает достаточное количество непрерывной памяти для хранения данных массива. Она выглядит как длинный ряд байтов,
                с каждым из которых сопоставлен определенный индекс массива. В одномерном массиве назначение индекса происходит просто: индекс i соответствует записи i.
                В двумерном аналогичная операция осуществляется одним из двух способов: путем развертывания по строкам или по столбцам.
                *   При развертывании по строкам программа привязывает первую строку записей массива к первому набору ячеек памяти, вторую — к следующему набору ячеек и т. д.
                    по одной строке за раз, пока все записи не будут приведены в соответствие.
                *   При развертывании по столбцам с первым набором ячеек памяти будет соотносится первый столбец записей массива, со вторым — второй и т. д.
            Эту же мысль о развертывании данных можно перенести и на массивы с большей размерностью. Например, для хранения трехмерного массива в построчном порядке программе 
                понадобится сопоставить первый двумерный слой массива с нулевым третьим индексом. Назначение происходит в построчном порядке, то есть второй слой будет соответствовать 
                третьему индексу под номером 1 и т. д.
        */
    }
    // 4.2 Одномерные массивы
    namespace std_4_2
    {
        /*
            Алгоритмы, в которых используются одномерные, или линейные, массивы, как правило, кажутся тривиальными. Операции с линейными массивами своего рода подспорье для работы с более 
                интересными структурами данных, такими как связные списки, стеки и очереди.
        */
        // 4.2.1 Нахождение элементов
        namespace std_4_2_1
        {
            /*
                Если элементы массива не отсортированы, то используется линейный, или исчерпывающий, поиск. При этом рассматривается каждый элемент массива, пока не находится целевой 
                    либо не становится очевидным его отсутствие.
            */
            template <typename T>
            int DArray<T>::indexOf(T data);
       }
       // 4.2.2 Нахождение минимальной, максимальной и средней величин
       namespace std_4_2_2
       {
            /*
                В числовом массиве нередко требуется найти минимальную, максимальную или среднюю величину.
            */
            template <typename T>
            T DArray<T>::findMin();

            template <typename T>
            T DArray<T>::findMax();

            template <typename T>
            T DArray<T>::findAvegage();

            /*
                Аналогичным образом можно рассчитать другие статистические величины, скажем, стандартное отклонение или дисперсию. Наибольшую трудность вызывает поиск срединного значения,
                    то есть такого, которое находится посередине в ряду всех значений массива. Например, среди чисел 1, 3, 4, 7, 8, 8, 9 срединным окажется 7, поскольку есть три числа меньше
                    его (1, 3, 4) и три больше (8, 8, 9). За один проход по массиву вы не получите всей информации, необходимой для определения срединного значения, так как для этого нужна
                    более общая информация о величинах.
                Один из способов решить подобную задачу — сравнить с каждым отдельно взятым значением оставшиеся значения из массива и проследить за тем, меньше они или больше тестового. 
                    Если количество меньших величин окажется равно количеству больших, тестовое значение и будет срединным. Далее приводится основной алгоритм.
            */
            template <typename T>
            inline T DArray<T>::findMedian();

            /*
                В приведенном алгоритме есть несколько недостатков. Например, он не сработает в случае, когда в массиве будут присутствовать одинаковые значения.
                Если в массиве N значений, внешний цикл For i выполняется N раз. Для каждой из этих итераций внутренний цикл For i срабатывает также N раз. Стало быть, во внутреннем цикле
                    совершается N u N = N2 шагов, что делает время работы алгоритма равным O(N2).
                Еще более быстрые алгоритмы занимаются поиском срединного значения в предварительно отсортированном числовом ряду. В главе 6 вы познакомитесь с различными способами сортировки 
                    массива, содержащего N элементов, за время O(N u log N) и убедитесь, что оно эффективнее, чем O(N2).
            */
       }
       // 4.2.3 Вставка элементов
       namespace std_4_2_3
       {
            /*
                Добавить элемент в конец линейного массива довольно просто при условии, что язык программирования может расширить массив на один элемент. Гораздо сложнее произвести вставку в 
                    произвольную позицию. Рассмотрим алгоритм, который добавляет новый элемент в позицию position в линейном массиве.
            */

            template <typename T>
            void DArray<T>::insertItem(T data, int index);

            /*
                Обратите внимание, что цикл алгоритма For запускается в конце массива и переходит к началу. Таким образом он заполняет сперва новую позицию в конце массива, а затем каждую предыдущую
                    сразу после того, как ее значение было скопировано в другое место.
                Если в исходном массиве было N элементов, цикл For сработает N – position раз. В наихудшем случае, когда элемент понадобится вставить в начало массива (то есть position = 0), цикл будет
                    вызван N раз, поэтому время работы такого алгоритма определяется как O(N).
                На практике вставка элементов в линейный массив не так уж распространена. Однако используемый метод смещения, который позволяет освободить место для нового элемента, широко применяется 
                    в других алгоритмах.
            */
        }
        // 4.2.4 Удаление элементов 
    }

}

/*
Глава 4. Массивы
Основные положения 
Одномерные массивы 
    Нахождение элементов 
    Нахождение минимальной, максимальной и средней величин 
    Вставка элементов 
    Удаление элементов
Ненулевые нижние пределы 
    Двумерные массивы
    Массивы высокой размерности 
Треугольные массивы 
Массивы с разрывом 
    Нахождение строки и столбца 
    Получение значения 
    Установка значения 
    Удаление значения
Матрицы 
Резюме 
Упражнения 
*/